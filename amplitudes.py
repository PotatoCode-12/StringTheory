import math
from scipy.integrate import quad
import numpy as np 
from sympy import symbols, diff,integrate, Function, Derivative, summation, oo, Abs, ln
import sympy as sp
import variables
import constants

def two_graviton_zero_graviton_amplitude():
    variables.GNewton**2*variables.CEnergy1**2*integrate(diff(variables.CEnergy1, variables.CEnergy1)) == variables.CEnergy2**2/constants.MassPlanck**4*integrate(diff(variables.CEnergy2, variables.CEnergy2)) #for intermediant states of high energy E'

variables.deltaa(variables.D) (variables.Xf(variables.sigma) - variables.xb(variables.D0)) == integrate((variables.dDf(variables.k))/(2*math.pi)**variables.D * math.exp(variables.brackets(variables.i*variables.k*(variables.Xf(variables.sigma) - variables.xb(variables.D0))))) # probe of worldsheet 103.12
integrate(variables.d2sigma * (variables.gf(variables.sigma))**(1/2) * integrate(variables.d2sigmap * (variables.gf(variables.sigmap))**(1/2) * variables.deltaa(variables.D) * (variables.Xf(variables.sigma) - variables.Xf(variables.sigmap)))) # check best implication of interaction 104.13

# 179.1 S- matrix
variables.Sb(variables.Db(2)) * (variables.kb(1), variables.kb(2), variables.kb(3)) == variables.gab(3, variables.o) * math.e**(-variables.lamda) * variables.bracketb(variables.point(variables.ca(1) * math.e**(variables.i * variables.kb(1) * variables.X) * variables.yb(1)) * variables.point(variables.ca(1) * math.e**(variables.i * variables.kb(2) * variables.X) * variables.yb(2)) * variables.point(variables.ca(1) * math.e**(variables.i * variables.kb(3) * variables.X) * variables.yb(3)), variables.Db(2)) + variables.bracketb(variables.point(variables.ca(1) * math.e**(variables.i * variables.kb(1) * variables.X) * variables.yb(1)) * variables.point(variables.ca(1) * math.e**(variables.i * variables.kb(3) * variables.X) * variables.yb(2)) * variables.point(variables.ca(1) * math.e**(variables.i * variables.kb(2) * variables.X) * variables.yb(3)), variables.Db(2))
variables.Sb(variables.Db(2)) * (variables.kb(1), variables.kb(2), variables.kb(3)) == variables.i* variables.gab(3, variables.o) * variables.Cb(variables.Db(2)) * (2 * math.pi)**(26) * variables.deltaa(26) * (summation(variables.kb(variables.i), variables.i)) * variables.bracketla(variables.yb(12), (1 + 2* variables.SlopeRegge * variables.kb(1) * variables.kb(2))) * variables.bracketla(variables.yb(13), (1 + 2 * variables.SlopeRegge * variables.kb(1) * variables.kb(3))) + variables.bracketla(variables.yb(23), (1 + 2 * variables.SlopeRegge * variables.kb(2) * variables.kb(3))) + variables.bracketla(variables.yb(12), (1 + 2* variables.SlopeRegge * variables.kb(1) * variables.kb(3))) * variables.bracketla(variables.yb(13), (1 + 2 * variables.SlopeRegge * variables.kb(1) * variables.kb(2))) + variables.bracketla(variables.yb(23), (1 + 2 * variables.SlopeRegge * variables.kb(3) * variables.kb(2))) 
variables.SlopeRegge * 2 * variables.kb(1) * variables.kb(2) == variables.SlopeRegge * (variables.kab(2, 3) - variables.kab(2, 1) - variables.kab(2, 2)) == -1
variables.Sb(variables.Db(2)) * (variables.kb(1), variables.kb(2), variables.kb(3)) == 2 * variables.i * variables.gab(3, variables.o) * variables.Cb(variables.Db(2)) * (2 * math.pi)**26 * variables.deltaa(26) * summation(variables.kb(variables.i), variables.i)
variables.Sb(variables.kb(1), variables.kb(2), variables.kb(3), variables.kb(4)) == variables.with_swap(variables.i * variables.gab(4, variables.o) * variables.Cb(variables.Db(2)) * (2 * math.pi)**26 * summation(variables.kb(variables.i), variables.i) * Abs(variables.yb(12) * variables.yb(13) * variables.yb(23)) * quad(diff(variables.yb(4) * np.prod(variables.bracketla(variables.yb(variables.i * variables.j), 2 * variables.SlopeRegge * variables.kb(variables.i) * variables.kb(variables.j)), variables.i<variables.j)), -math.inf, math.inf))
#variables.gab(4, variables.o) * math.e**(-variables.lamda) * quad(diff(variables.yb(4)) * variables.bracket(np.prod(variables.point(variables.caf(1, variables.yb(variables.i)) * math.e**(variables.i * variables.kb(variables.i) * variables.Xf(variables.yb(variables.i)))) * variables.point(math.e**(variables.i * variables.kb(4) * variables.Xf(variables.yb(4)))), (variables.i, 1, 3))), -math.inf, math.inf), ignored permutations for intermediate
variables.s == -(variables.kb(1) + variables.kb(2))**2
variables.t == -(variables.kb(1) + variables.kb(3))**2
variables.u == - (variables.kb(1) + variables.kb(4))**2
variables.s + variables.t + variables.u == summation(variables.mab(2, variables.i), variables.i) == -4/(variables.SlopeRegge)
# check amplitude 180.8 and integral with applied vertex operators 180.9
variables.If(variables.s, variables.t) == quad(diff(variables.y) * variables.ya(-variables.SlopeRegge * variables.s-2) * (1-variables.y)**(-variables.SlopeRegge * variables.t - 2), 0, 1)
#check analytic term expansion181.11
1/(variables.SlopeRegge * variables.s + 1) == 1/(variables.SlopeRegge * variables.s + 1 + variables.i * variables.epsilon) == variables.P * 1/(variables.SlopeRegge * variables.s + 1) - variables.i * math.pi * variables.delta * (variables.SlopeRegge * variables.s + 1)
#omitted analytic term intermediate, 182.13
variables.Cb(variables.Db(2)) == variables.ea(-variables.lamda) * variables.Cab(variables.X, variables.Db(2)) * variables.Cab(variables.g, variables.Db(2)) == 1/(variables.SlopeRegge * variables.gab(2, variables.o))
variables.Sb(variables.Db(2)) * (variables.kb(1), variables.kb(2), variables.kb(3)) == (2*variables.i * variables.gb(variables.o))/(variables.SlopeRegge) * (2 * math.pi) **26 * variables.deltaa(26) * summation(variables.kb(variables.i), variables.i)
#182.16-18, extensive or analyitic term expansion
variables.Bf(variables.a, variables.b) == quad(diff(variables.y) * variables.ya(variables.a - 1) * (1 - variables.y)**(variables.b-1), 0, 1)
variables.If(variables.s, variables.t) == variables.Bf(-variables.alphabf(variables.o, variables.s), -variables.alphabf(variables.o, variables.t))
variables.alphabf(variables.o, variables.x) == 1 + variables.SlopeRegge * variables.x 
variables.wa(variables.a + variables.b - 1) * variables.Bf(variables.a, variables.b) == quad(diff(variables.v) * variables.va(variables.a - 1) * (variables.w - variables.v)**(variables.b -1 ), 0, variables.w)
variables.Rho(variables.a + variables.b) * variables.Bf(variables.a, variables.b) == quad(diff(variables.v) * variables.va(variables.a - 1) * variables.ea(-variables.v) * quad(diff(variables.w - variables.v) * (variables.w-variables.v)**(variables.k), 0 , math.inf), 0, math.inf) == variables.Rho(variables.a) * variables.Rho(variables.b)
variables.Sb(variables.Db(2)) * (variables.kb(1), variables.kb(2), variables.kb(3), variables.kb(4)) == (2 * variables.i * variables.gab(2, variables.o))/(variables.SlopeRegge)* (2 * math.pi)**26 * variables.deltaa(26) * summation(variables.kb(variables.i), variables.i) * variables.brackets(variables.Bf(-variables.alphabf(variables.o, variables.s), - variables.alphabf(variables.o, variables.t)) + variables.Bf(-variables.alphabf(variables.o, variables.s), -variables.alphabf(variables.o, variables.u) + variables.Bf(-variables.alphabf(variables.o, variables.t), - variables.alphabf(variables.o, variables.u))))
# regge and hard scattering limits:
#variables.s == math.inf # t == fixed
#variables.s == math.inf #t/s == fixed
variables.s == variables.E**(2) 
variables.t == (4 * variables.m**2 - variables.E**2) * (math.sin(variables.theta/2))**2
variables.u == (4 * variables.m**2 - variables.E**2) * (math.cos(variables.theta/2))**2
# check approx bounds on 184.28 & 29

#216.1 torus amplitudes
variables.B == 1/(4 * math.pi)(variables.b, diff(variables.g, variables.tau)) == 1/(2 * math.pi) * integrate(variables.d2(variables.w) * variables.bbf(variables.w * variables.w, variables.w) * diff(variables.gb(variables.wl * variables.wl), variables.tau)) == variables.i/(4 * math.pi * variables.taub(2)) * integrate(variables.d2(variables.w) * variables.bbf(variables.w * variables.w, variables.w)) == 2 * math.pi * variables.i * variables.bbf(variables.w * variables.w, 0)
variables.Zb(variables.Ta(2)) == integrate((diff(variables.tau) * diff(variables.taul))/(4 * variables.taub(2)) * variables.bracketb(variables.bf(0) * variables.bftilde(0) * variables.cftilde(0) * variables.cf(0), variables.Ta(2)), variables.Fb(0)) # fixed vertext operator
variables.Zb(variables.Ta(2)) == variables.i * variables.Vb(26) * integrate((diff(variables.tau) * diff(variables.taul))/(4 * variables.taub(2)) * (4 * math.pi * variables.SlopeRegge * variables.taub(2))**(-13) * Abs(variables.etaf(variables.tau))**(-48), variables.Fb(0)) # for flat dimensions
variables.Zb(variables.Ta(2)) == variables.Vb(variables.d) * integrate((diff(variables.tau) * diff(variables.taul))/(4 * variables.taub(2)) * integrate((variables.da(variables.d) * variables.k)/(2 * math.pi)**variables.d * math.exp(-math.pi * variables.taub(2) * variables.SlopeRegge * variables.ka(2)) * summation(variables.qa(variables.hb(variables.i)-1) * variables.qla(variables.hbtilde(variables.i)-1), (variables.i, variables.hilberta(variables.perp)))), variables.Fb(0)) == variables.i * variables.Vb(variables.d) * variables.integrate((diff(variables.tau) * diff(variables.taul))/(4 * variables.taub(2)) * (4 * math.pi**2 * variables.SlopeRegge * variables.taub(2))**(-variables.d/2) * summation(variables.qa(variables.hb(variables.i) - 1) * variables.qla(variables.hbtilde(variables.i) - 1)), (variables.i, variables.hilberta(variables.perp)), variables.Fb(0))
variables.Zbf(variables.Sb(1), variables.m**(2))  == variables.Vb(variables.d) * integrate((variables.da(variables.d) * variables.k)/(2 * math.pi)**variables.d * quad((variables.d*(variables.l))/(2 * variables.l), 0, math.inf)) * math.exp(-(variables.ka(2) + variables.ma(2)) * variables.l/2) == variables.i * variables.Vb(variables.d) * quad((variables.d * variables.l)/(2 * variables.l) * (2 * math.pi * variables.l)**(-variables.d/2) * math.exp(-variables.ma(2) * variables.l/2), 0, math.inf) # sum over all paths with topology of a circle
variables.ma(2) == 2/variables.SlopeRegge * (variables.h + variables.htilde - 2)
variables.deltab(variables.h, variables.htilde) == quad((diff(variables.theta))/(2 * math.pi), -math.pi, math.pi) * math.exp(variables.i * (variables.h - variables.htilde) * variables.theta)
summation(variables.Zbf(variables.Sb(1), variables.mab(2, variables.i)),(variables.i, variables.hilberta(variables.perp))) == np.cross(variables.i * variables.Vb(variables.d) * quad((variables.d * variables.l)/(2 * variables.l) * quad((variables.d * variables.theta)/(2 * math.pi) * (2 * math.pi * variables.l)**(-variables.d/2), -math.pi, math.pi), 0, math.inf), summation(math.exp(variables.brackets(-(variables.hb(variables.i) + variables.hbtilde(variables.i) - 2) * variables.l/variables.SlopeRegge + variables.i * (variables.hb(variables.i) - variables.hbtilde(variables.i)) * variables.theta)), (variables.i, variables.hilberta(variables.perp)))) == variables.i * variables.Vb(variables.d) * integrate((diff(variables.tau) * diff(variables.taul))/(4 * variables.taub(2)) * (4 * math.pi**2 * variables.SlopeRegge * variables.taub(2))**(-variables.d/2) * summation(variables.qa(variables.hb(variables.i) - 1) * variables.qla(variables.hbtilde(variables.i) - 1), (variables.i, variables.hilberta(variables.perp))), variables.R)
#region of integration R:
variables.taub(2) > 0
Abs(variables.taub(1)) < 1/2
# fundemental region Fb(0):
Abs(variables.tau) > 1
Abs(variables.taub(1)) < 1/2 
variables.taub(2) > 0
# general cft 218.12 transformation:
variables.i * variables.Vb(variables.d) * integrate((variables.d * variables.taub(2))/(2 * variables.taub(2)) * (4 * math.pi**2 * variables.SlopeRegge * variables.taub(2))**(-variables.d/2) * summation(math.exp(-math.pi * variables.SlopeRegge * variables.mab(2, variables.i) * variables.taub(2)), variables.i)) # cutoff at math.inf
#vacuum amplitude
variables.ZBbf(variables.vac, variables.ma(2)) == math.exp(variables.brackets(variables.Zbf(variables.Sb(1), variables.ma(2))))
variables.ZBbf(variables.vac, variables.ma(2)) == variables.bracket(0, math.exp(-variables.i * variables.H * variables.T), 0) == math.exp(-variables.i * variables.rhob(0) * variables.Vb(variables.d))
#vacuum energy density
variables.rhob(0) == variables.i/(variables.Vb(variables.d)) * variables.Zbf(variables.Sb(1), variables.ma(2))
#dropping divergent terms
variables.quad((variables.d * variables.l)/(2 * variables.l),0, math.inf) * math.exp(-(variables.ka(2) + variables.ma(2)) * variables.l/2) == -1/2 * ln(variables.ka(2) +variables.ma(2))
variables.i * quad((variables.d * variables.l)/(2 * variables.l) * quad((variables.d * variables.ka(0))/(2 * math.pi), -math.inf, math.inf), 0, math.inf) == (variables.omegabs(variables.kB))/2
variables.rhob(0) == integrate((variables.da(variables.d-1) * variables.kB)/(2 * math.pi)**((variables.d-1)) * (variables.omegabs(variables.kB))/2)
ln(variables.ZBbf(variables.vac, variables.ma(2))) == -1/2 * variables.Tr * ln(-variables.diff2 + variables.ma(2)) == -(variables.Vb(variables.d))/2 * integrate((variables.da(variables.d))/((2 * math.pi)**variables.d) * ln(variables.ka(2) + variables.ma(2)))
variables.rhob(0) == variables.i/(variables.Vb(variables.d)) * summation((-1)**variables.FBb(variables.i) * variables.Zbf(variables.Sb(1), variables.mab(2, variables.i)), variables.i)
# check GeV counts on 222.25,26
#for cylinder unoriented theory
variables.Zb(variables.Cb(2)) == quad((variables.d * variables.t)/(2 * variables.t), 0, math.inf) * variables.Trbpf(variables.brackets(math.exp(-2 * math.pi * variables.t * variables.Lb(0)))) == variables.i * variables.Vb(variables.d) * quad((variables.d * variables.t)/(2 * variables.t) * (8 * math.pi**2 * variables.SlopeRegge * variables.t)**(-variables.d/2), 0, math.inf) * summation(math.exp(variables.brackets(-2 * math.pi * variables.t * (variables.hb(variables.i) -1))), (variables.i, variables.hilbertab(variables.perp, variables.o))) == variables.i * variables.Vb(26) * variables.na(2) * quad((variables.d * variables.t)/(2 * variables.t) * (8 * math.pi * variables.SlopeRegge * variables.t)**(-13) * variables.etaf(variables.i * variables.t)**(-24), 0, math.inf)
variables.etaf(variables.i * variables.t) == variables.t**(-1/2) * variables.etaf(variables.i/variables.t)
variables.Zb(variables.Cb(2)) == variables.i * (variables.Vb(26) * variables.na(2))/(2 * math.pi * (8 * math.pi**2 * variables.SlopeRegge)**13) * quad(variables.d * variables.s * variables.etaf(variables.i*variables.s/math.pi)**(-24), 0, math.inf)
variables.etaf(variables.i * variables.s/math.pi)**(-24) == math.exp(2 * variables.s) * np.prod(variables.brackets(1- math.exp(-2 * variables.n * variables.s))**(-24), (variables.n, 1, math.inf)) == math.exp(2 * variables.s) + 24 + variables.Of(math.exp(-2 * variables.s))
quad(variables.d * variables.s * math.exp(variables.Beta * variables.s), 0, math.inf) == -1/(variables.Beta)
#check action for associated equation of motion below
diff(variables.phi, variables.z, 2) == variables.g * variables.Lamda
#path integral is proportional to 226.11
variables.bracket(variables.B, variables.cb(0) * variables.bb(0) * math.exp(variables.bracket(-variables.s * (variables.Lb(0) + variables.Lbtilde(0)))), variables.B)
#Laurent coefficent
(variables.alphaab(variables.mu, variables.n) + variables.alphaabtilde(variables.mu, -variables.n)) * variables.dirac(variables.B) == (variables.cb(variables.n) + variables.cbtilde(-variables.n)) * variables.dirac(variables.B) == (variables.bb(variables.n) - variables.bbtilde(-variables.n)) * variables.dirac(variables.B) == 0 # for all n
#klein bottle vacuum amplitude
variables.Zb(variables.Kb(2)) == quad((variables.d * variables.t)/(4 * variables.t), 0, math.inf) * variables.Trbpf(variables.bracketc(variables.omega * math.exp(variables.brackets(-2 * math.pi * variables.t * (variables.Lb(0) + variables.Lbtilde(0)))))) == variables.i * variables.Vb(variables.d) * quad((variables.d * variables.t)/(4 * variables.t) * (4 * math.pi * variables.SlopeRegge * variables.t)**(-variables.d/2), 0, math.inf) * summation(variables.omegab(variables.i) * math.exp(variables.brackets(-2 * math.pi * variables.t *(variables.hb(variables.i) + variables.hbtilde(variables.i) - 2))), (variables.i, variables.hilbertab(variables.perp, variables.c)))
variables.Zb(variables.Kb(2)) == variables.i * variables.Vb(26) * variables.quad((variables.d * variables.t)/(4 * variables.t) * (4 * math.pi **2 * variables.SlopeRegge * variables.t)**(-13) * variables.etaf(2 * variables.i * variables.t)**(-24), 0, math.inf)
variables.w == variables.w + 2 * math.pi == -variables.wl + 2 * math.pi * variables.i * variables.t  # fundemental region identification
variables.w == variables.w + 4 * math.pi * variables.i * variables.t 
variables.w + math.pi == -(variables.wl + math.pi) + 2 * math.pi * variables.i * variables.t 
variables.Zb(variables.Kb(2)) == variables.i * (2**26 * variables.Vb(26))/(4 * math.pi * (8 * math.pi**2 * variables.SlopeRegge)**(13)) * quad(variables.d * variables.s * variables.etaf(variables.i * variables.s/math.pi)**(-24), 0, math.inf)
# mobius strip
variables.Zb(variables.Mb(2)) == variables.i * variables.Vb(variables.d) * quad((variables.d * variables.t)/(4 * variables.t) * (8 * math.pi**2 * variables.SlopeRegge * variables.t)**(-variables.d/2), 0, math.inf) * summation(variables.omegab(variables.i) * math.exp(variables.brackets(-2 * math.pi * variables.t *(variables.hb(variables.i) - 1))), (variables.i, variables.hilbertab(variables.perp, variables.o)))
# oscillator trace
math.exp(2 * math.pi * variables.t) * np.prod(variables.brackets( 1 - (-1)**(variables.n) * math.exp(-2 * math.pi * variables.n * variables.t))**(-24), (variables.n, 1, math.inf)) == variables.thetavarb((0, 0), 0, 2 * variables.i * variables.t)**(-12) * variables.etaf(2 * variables.i * variables.t)**(-12)
variables.Zb(variables.Mb(2)) == variables.posneg * variables.i * variables.n * variables.Vb(26) * quad((variables.d * variables.t)/(4 * variables.t) * (8 * math.pi * variables.SlopeRegge * variables.t)**(-13) * variables.thetavarb((0, 0), 0, 2 * variables.i * variables.t)**(-12) * variables.etaf(2 * variables.i * variables.t)**(-12), 0, math.inf)
variables.Zb(variables.Mb(2)) == variables.posneg * 2 * variables.i * variables.n * (2 **13 * variables.Vb(26))/(4 * math.pi * (8 * math.pi**2 * variables.SlopeRegge)**13) * quad(variables.d * variables.s * variables.thetavarb((0, 0), 0, 2 * variables.i * variables.s/math.pi)**(-12) * variables.etaf(2 * variables.i * variables.s/math.pi)**(-12), 0, math.inf)
# divergences on the three surfaces combine to:
variables.i * (24 * variables.Vb(26))/(4 * math.pi * (8 * math.pi**2 * variables.SlopeRegge)**(13)) * (2 **13 + variables.negpos * variables.n)**2 * quad(variables.d * variables.s, 0 , math.inf)

# 284.3, nromalization
variables.ea(-2 * variables.lamda) * variables.bracket(variables.cftilde(variables.zlb(1)) * variables.cf(variables.zb(1)) * variables.cftilde(variables.zlb(2)) * variables.cf(variables.zb(2)) * variables.cftilde(variables.zlb(3)) * variables.cf(variables.zb(3)) * variables.point(variables.ea(np.dot(variables.i * variables.k, variables.X)) * (variables.z, variables.zl))) == (8 * math.pi * variables.i)/(variables.SlopeRegge * variables.gab(2, (variables.c, variables.d))) * Abs(variables.zb(12) * variables.zb(13) * variables.zb(23))**2 * (2 * math.pi)**variables.d * variables.deltaaf(variables.d, variables.k)
variables.Sbf(variables.Sb(2), (1, 2, 3)) == variables.ea(-2 * variables.lamda) * variables.bracketb(variables.hat(variables.VObfp(1, (math.inf, math.inf))) * variables.hat(variables.VObf(2, (1, 1))) * variables.hat(variables.VObf(3, (0, 0))), variables.Sb(2))
variables.hat(variables.VOb(variables.j)) == variables.ctilde * variables.c * variables.VOb(variables.j) 
variables.Sbf(variables.Sb(2), (1, 2, 3)) == variables.ea(-2 * variables.lamda) * variables.bracket(variables.dirac(variables.hat(variables.VOb(1)), variables.hat(variables.VObf(2, (1, 1))), variables.hat(variables.VOb(3)))) == variables.ea(-2 * variables.lamda) * variables.cb((1, 2, 3))
variables.dirac(variables.hat(variables.VOb(3))) == variables.Qb(variables.B) * variables.dirac(variables.chi)
variables.ea(2 * variables.lamda) * variables.Sbf(variables.Sb(2), (1, 2, 3)) == variables.bracket(variables.dirac(variables.hat(variables.VOb(1)), variables.brackets(variables.VObf(2, (1, 1)), variables.Qb(variables.B)), variables.chi)) + variables.bracket(variables.dirac(variables.hat(variables.VOb(1)), variables.Qb(variables.B) * variables.hat(variables.VObf(2, (1, 1))), variables.chi)) == 0
variables.hat(variables.VOb(3)) == np.dot(variables.Qb(variables.B), variables.XO)
variables.Sb(variables.m * variables.n) == variables.deltab(variables.m * variables.n) + variables.i * variables.Tb(variables.m * variables.n)
variables.Tb(variables.m * variables.p) - variables.star(variables.Tb(variables.p * variables.m)) == variables.i * summation(variables.Tb(variables.m * variables.n) * variables.star(variables.Tb(variables.p * variables.n)), variables.n)
variables.Tbf(variables.Sb(2), (1, 2, 3)) == variables.Tbf(variables.Sb(2), variables.star(-1, -2, -3))
variables.hat(variables.VOb(-variables.i)) == -variables.hat(variables.VObl(variables.i))
variables.Sbf(variables.Sb(2), (1, 2, 3, 4)) == variables.ea(-2 * variables.lamda) * integrate(variables.d2z * variables.bracket(variables.hat(variables.VObf(1, (math.inf, math.inf))) * variables.hat(variables.VObf(2, (1, 1))) * variables.hat(variables.VObf(3, (0, 0))) * variables.VObf(4, (variables.z, variables.zl))), variables.C) # check if bolded C, 286.16
variables.bracket(variables.dirac(variables.hat(variables.VOb(1)), variables.Tf(variables.brackets(variables.hat(variables.VObf(2, (1, 1))) * variables.VObf(4, (variables.z, variables.zl)))), variables.hat(variables.VOb(3))))
variables.VObf(4, (variables.z, variables.zl)) == (variables.z * variables.zl)**(-1) * variables.bracketc(variables.bb(0), variables.brackets(variables.bbtilde(0), variables.VObf(4, (variables.z, variables.zl))))
variables.theta * (1- Abs(variables.z)) * variables.bracket(variables.dirac(variables.hat(variables.VOb(1)), variables.hat(variables.VObf(2, (1, 1))) * variables.bb(0) * variables.bbtilde(0) * variables.za(variables.Lb(0) - 1) * variables.hat(variables.VObf(4, (1, 1))), variables.hat(variables.VOb(3)))) + variables.theta * (Abs(variables.z) - 1) * variables.bracket(variables.dirac(variables.hat(variables.VOb(1)), variables.hat(variables.VObf(4, (1, 1))) * variables.bb(0) * variables.bbtilde(0) * variables.za(-variables.Lb(0) - 1) * variables.zla(variables.Lbtilde(0) - 1) * variables.hat(variables.VObf(2, (1, 1))), variables.hat(variables.VOb(3))))
# check intermediant states 287.20
variables.kab(2, variables.i) == (variables.kb(1) + variables.kb(2))**2 > 4/variables.SlopeRegge 
integrate(variables.d2z * variables.za(variables.SlopeRegge * (variables.ka(2) + variables.ma(2))/4 -1) * variables.zla(variables.SlopeRegge * (variables.ka(2) + variables.matilde(2))/4 - 1), Abs(variables.z)< 1) == (8 * math.pi)/variables.SlopeRegge * (variables.deltab((variables.ma(2), variables.matilde(2))))/(variables.ka(2) + variables.ma(2) - variables.i * variables.epsilon)
variables.brackets(variables.bb(0) * variables.bbtilde(0) * variables.za(variables.posneg * variables.Lb(0) - 1) * variables.zla(variables.posneg * variables.Lbtilde(0) - 1), variables.Qb(variables.B)) == variables.posneg * variables.bb(0) * diff(variables.za(variables.posneg * variables.Lb(0) - 1) * variables.zla(variables.posneg * variables.Lbtilde(0)), variables.zl) + variables.negpos * variables.bbtilde(0) * diff(variables.za(variables.posneg * variables.Lb(0)) * variables.zla(variables.posneg * variables.Lbtilde(0) -1), variables.z)
# check voided permutations based equations 288.24 & 26
1/(variables.ka(2) + variables.ma(2) - variables.i * variables.epsilon) - 1/(variables.ka(2) + variables.ma(2) + variables.i * variables.epsilon) == 2 * math.pi * variables.i * variables.delta(variables.ka(2 + variables.ma(2)))
variables.i == (variables.j, variables.k)
summation(variables.deltab(variables.mab(2, variables.i), variables.mabtilde(2, variables.i)) * variables.delta * (variables.kab(2, variables.i) + variables.mab(2, variables.i)) * variables.bb(0) * variables.bbtilde(0 * variables.dirac(variables.i) * variables.gOa(variables.i * variables.ip) * variables.diracbs(variables.ip))) == variables.deltab(variables.Lb(0), variables.Lbtilde(0)) * variables.delta * ((4 * variables.Lb(0))/variables.SlopeRegge) * variables.bb(0) * variables.bbtilde(0) == - (variables.i * variables.SlopeRegge)/(16 * math.pi**2 * variables.ea(2 * variables.lamda)) * integrate((variables.da(variables.d - 1) * variables.kB)/(2 * variables.E * (2 * math.pi)**(variables.d -1)) * summation(variables.dirac(variables.hat(variables.VObf(variables.j, variables.k))) * variables.diracbs(variables.hat(variables.VObfl(variables.j, variables.k))), (variables.j, variables.hat(variables.hilbert), variables.ka(0) == variables.posneg * variables.omegasb(variables.k)))) # check summation conditions
variables.bracket(variables.dirac(variables.hat(variables.VObfl(variables.j, variables.k)), variables.cbtilde(0) * variables.cb(0), variables.hat(variables.VObf(variables.jp, variables.kp)))) == (8 * math.pi * variables.i * variables.ea(2 * variables.lamda))/variables.SlopeRegge * variables.deltab(variables.j * variables.jp) * (2 * math.pi)**variables.d * variables.deltaa(variables.d) * (variables.k - variables.kp)
variables.pOf(variables.diracb(variables.b, variables.P)) == variables.diracb(variables.b, variables.P)
variables.pOf(variables.diracb(variables.a, variables.U)) == 0
variables.pOf(variables.diracb(variables.a, variables.N)) == 0
variables.uOf(variables.diracb(variables.b, variables.P)) == 0
variables.uOf(variables.diracb(variables.a, variables.U)) == 0
variables.uOf(variables.diracb(variables.a, variables.N)) == variables.diracb(variables.a, variables.U)
1 == variables.pO + variables.Qb(variables.B) * variables.uO + variables.uO * variables.Qb(variables.B)
-variables.i * variables.etaa(variables.mu * variables.v)/(variables.ka(2))
variables.etaa(variables.mu * variables.v) == (variables.etaa(variables.mu * variables.v) - variables.ka(variables.mu) * variables.na(variables.v) - variables.va(variables.mu) * variables.ka(variables.v)) + variables.ka(variables.mu) * variables.na(variables.v) + variables.na(variables.mu) * variables.ka(variables.v)
(diff(variables.zb(1), variables.z))/diff(variables.z, variables.z) == (variables.zb(1))/variables.z # check evaluation terms 290.34

#305.1
integrate((diff(variables.z))/(2 * math.pi * variables.i) * variables.bb(variables.zb(1) * variables.zb(1)) (diff(variables.zb(1), variables.z))/(diff(variables.q, variables.z))) == (variables.bb(0))/variables.q # check evaluation bounds + contour integral
integrate((variables.d2(variables.q))/(variables.q * variables.ql) * variables.qa(variables.SlopeRegge * (variables.kab(2, variables.i) + variables.mab(2, variables.i))/4) * variables.qla(variables.SlopeRegge * (variables.kab(2, variables.i) + variables.mabtilde(2, variables.i))/4) * variables.gOa(variables.i * variables.j) * variables.bb(0) * variables.bbtilde(0), Abs(variables.q) < 1) == (8 * math.pi * variables.deltab(variables.mab(2, variables.i), variables.mabtilde(2, variables.i)) * variables.gOa(variables.i * variables.j) * variables.bb(0) * variables.bbtilde(0))/(variables.SlopeRegge * (variables.kab(2, variables.i) + variables.mab(2, variables.i) - variables.i * variables.epsilon))
# ignored 305.3
diff(variables.xa(variables.mu), variables.z) * diff(variables.xb(variables.mu), variables.zl) * (diff(variables.q) * diff(variables.ql))/(variables.q * variables.ql)
-4 * math.pi * diff(variables.xa(variables.mu), variables.z) * diff(variables.xb(variables.mu), variables.zl) * ln(variables.a * variables.ea(-variables.omegas))
variables.delta * variables.SB == - summation(variables.Lamdab(variables.chi) * integrate(variables.da(variables.d) * variables.x * (-variables.G)**(1/2) * variables.ea(-variables.chia(variables.Phi))), variables.chi)

#2.110.1
1/(variables.SlopeRegge* variables.gab(2, variables.o)) * variables.brackets(variables.c * variables.VOabf(-1, 1, variables.xbs(1)) * variables.c * variables.VOabf(-1, 2, variables.xbs(2)) * variables.c * variables.VOabf(0, 3, variables.xbs(3))) + (variables.VOb(1))
# where
variables.VOb(1) == variables.VOb(2)
variables.bracket(variables.cf(variables.xbs(1)) * variables.cf(variables.xbs(2)) * variables.cf(variables.xbs(3))) == variables.xbs(12) * variables.xbs(13) * variables.xbs(23)
variables.bracket(variables.eaf(-variables.phi, variables.xbs(1)) * variables.eaf(-variables.phi, variables.xbs(2))) == variables.xabs(-1, 12)
variables.bracket(variables.psiaf(variables.mu, variables.xbs(1)) * variables.psiaf(variables.v, variables.xbs(2))) == variables.etaa(variables.mu * variables.v) * variables.xabs(-1, 12)
variables.bracket(variables.psia(variables.mu) * variables.eaf(np.dot(variables.i * variables.kb(1), variables.X), variables.xbs(1)) * variables.psia(variables.v) * variables.eaf(np.dot(variables.i * variables.kb(2), variables.X), variables.xbs(2)) * (variables.i * diff(variables.xa(variables.rho), variables.tau) + np.dot(2 * variables.SlopeRegge * variables.kb(3), variables.psi) * variables.psia(variables.rho)) * variables.eaf(np.dot(variables.i * variables.kb(3), variables.X), variables.xbs(3))) == 2 * variables.i * variables.SlopeRegge * (2 * math.pi)**10 * variables.deltaa(10) * (summation(variables.kb(variables.i), variables.i)) * (-(variables.etaa(variables.mu * variables.v) * variables.kab(variables.rho, 1))/(variables.xbs(12) * variables.xbs(13)) - (variables.etaa(variables.mu * variables.v) * variables.kab(variables.rho, 2))/(variables.xbs(12) * variables.xbs(23)) + (variables.etaa(variables.mu * variables.rho) * variables.kab(variables.v, 3) - variables.etaa(variables.v * variables.rho) * variables.kab(variables.mu, 3))/(variables.xbs(13) * variables.xbs(23)))
variables.i * variables.gb(variables.YM) * (2 * math.pi)**10 * variables.deltaa(10) * summation(variables.kb(variables.i), variables.i) * variables.eb(1, variables.mu) * variables.eb(2, variables.v) * variables.eb(3, variables.rho) * variables.Va(variables.mu * variables.v, variables.rho) * variables.Trbf(variables.v, variables.brackets(variables.ta(variables.ab(1)), variables.ta(variables.ab(2))) * variables.ta(variables.ab(3)))
variables.Va(variables.mu * variables.v, variables.rho) == variables.etaa(variables.mu * variables.v) * variables.kab(variables.rho, 12) + variables.etaa(variables.v, variables.rho) * variables.kab(variables.mu, 23) + variables.etaa(variables.rho * variables.mu) * variables.kab(variables.v, 31)
variables.bracket(variables.eaf(-variables.phi/2, variables.xbs(1)) * variables.eaf(-variables.phi/2, variables.xbs(2)) * variables.eaf(-variables.phi, variables.xbs(3))) == variables.xabs(-1/4, 12) * variables.xabs(-1/2, 13) * variables.xabs(-1/2, 23)
variables.bracket(variables.Thetabf(variables.alpha, variables.xbs(1)) * variables.Thetabf(variables.Beta, variables.xbs(2))) == variables.xabs(-5/4, 12) * variables.Cb(variables.alpha * variables.Beta)
variables.bracket(variables.Thetabf(variables.alpha, variables.xbs(1)) * variables.Thetabf(variables.Beta, variables.xbs(2)) * variables.psiaf(variables.mu, variables.xbs(3))) == 2**(-1/2) * variables.holderb(variables.C * variables.Rhoa(variables.mu), variables.alpha * variables.Beta) * variables.xabs(-3/4, 12) * variables.xabs(-1/2, 13) * variables.xabs(-1/2, 23)
variables.psiaf(variables.mu, variables.x) * variables.Thetabf(variables.alpha, 0) == (2 * variables.x)**(-1/2) * variables.Thetabf(variables.Beta, 0) * variables.Rhoab(variables.mu, variables.Beta * variables.alpha) + variables.Of(variables.xas(1/2))
variables.i * variables.gb(variables.YM) * (2 * math.pi)**(10) * variables.deltaa(10) * variables.summation(variables.kb(variables.i, variables.i)) * variables.eb(variables.mu) * variables.ubl(1) * variables.Rhoa(variables.mu) * variables.ub(2) * variables.Trbf(variables.mu, (variables.brackets(variables.ta(variables.ab(1)), variables.ta(variables.ab(2))) * variables.ta(variables.ab(3))))
variables.bracket(variables.jaf(variables.a, variables.zb(1)) * variables.jaf(variables.b, variables.zb(2))) == (variables.hat(variables.k) * variables.deltaa(variables.a * variables.b))/(variables.zab(2, 12))
variables.bracket(variables.jaf(variables.a, variables.zb(1)) * variables.jaf(variables.b, variables.zb(2)) * variables.jaf(variables.c, variables.zb(3))) == (variables.i * variables.hat(variables.k) * variables.fa(variables.a * variables.b * variables.c))/(variables.zb(12) * variables.zb(13) * variables.zb(23))
variables.i * variables.hat(variables.ka(-1/2)) * variables.fa(variables.a * variables.b * variables.c) == 2 **(1/2) * variables.Trbf(variables.v, (variables.brackets(variables.ta(variables.a), variables.ta(variables.b)) * variables.ta(variables.c)))
variables.bracket(np.prod(np.dot(variables.i * variables.eb(variables.i), diff(variables.X * variables.eaf(np.dot(variables.i * variables.kb(variables.i), variables.X), (variables.zb(variables.i), variables.zlb(variables.i))), variables.z)), (variables.i, 1, 3))) == (variables.alphaatilde(2) * variables.eb(1, variables.mu) * variables.eb(2, variables.v) * variables.eb(3, variables.rho) * variables.Ta(variables.mu * variables.v, variables.rho))/(8 * variables.i * variables.zb(12) * variables.zb(13) * variables.zb(23))
variables.Ta(variables.mu * variables.v, variables.rho) == variables.kab(variables.mu, 23) * variables.etaa(variables.v, variables.rho) + variables.lab(variables.v, 31) * variables.etaa(variables.rho * variables.mu) + variables.kab(variables.rho, 12) * variables.etaa(variables.mu * variables.v) + variables.SlopeRegge/8 * variables.kab(variables.mu, 23) * variables.kab(variables.v, 31) * variables.kab(variables.rho, 12)
8 * math.pi * variables.gb(variables.c) * variables.alphaatilde(-1/2) * (2 * math.pi)**10 * variables.deltaaf(10, summation(variables.kb(variables.i), variables.i)) * variables.eb(1, variables.mu) * variables.eb(2, variables.v) * variables.eb(3, variables.rho) * variables.Va(variables.mu * variables.v, variables.rho) * variables.Trbf(variables.v, (variables.brackets(variables.ta(variables.a), variables.ta(variables.b)) * variables.ta(variables.c)))
math.pi * variables.i * variables.gb(variables.c) * (2 * math.pi)**(10) * variables.deltaaf(10, summation(variables.kb(variables.i), variables.i)) * variables.eb(1, variables.mu * variables.sigma) * variables.eb(2, variables.v * variables.omegas) * variables.eb(3, variables.rho * variables.lamda) * variables.Ta(variables.mu * variables.v, variables.rho) * variables.Va(variables.sigma * variables.omegas * variables.lamda)
math.pi * variables.i * variables.gb(variables.c) * (2 * math.pi)**10 * variables.deltaaf(summation(variables.kb(variables.i),variables.i)) * variables.eb(1, variables.mu * variables.v) * variables.eb(2, variables.rho) * variables.eb(3, variables.sigma) * variables.kab(variables.v, 23) * variables.Va(variables.mu * variables.rho * variables.sigma) * variables.deltaa(variables.a * variables.b)
math.pi * variables.i * variables.gb(variables.c) * (2 * math.pi)**10 * variables.deltaaf(10, summation(variables.kb(variables.i), variables.i)) * variables.eb(1, variables.mu * variables.sigma) * variables.eb(2, variables.v * variables.omegas) * variables.eb(3, variables.rho * variables.lamda) * variables.Va(variables.mu * variables.v, variables.rho) * variables.Va(variables.sigma * variables.omegas * variables.lamda)
(-variables.Gb(variables.h))**(1/2) * variables.ea(-2 * variables.Phib(variables.h)) * variables.Rab(2, variables.h) == (-variables.Gb(variables.I))**(1/2) * variables.ea(-variables.Phib(variables.I)) * variables.Rab(2, variables.I)
#check 2.114.18 OPE approx
variables.bracket(variables.VObf(variables.alpha, variables.zb(1)) * variables.VObf(variables.Beta, variables.zb(2)) * variables.VObf(variables.gamma, variables.zb(3)) * variables.VObf(variables.delta , variables.zb(4))) == (variables.holderb(variables.C * variables.Rhoa(variables.mu), variables.alpha * variables.Beta) * variables.holderb(variables.C * variables.Rhob(variables.mu), variables.gamma* variables.delta))/(2 * variables.zb(12) * variables.zb(23) * variables.zb(24) * variables.zb(34)) + (variables.holderb(variables.C * variables.Rhoa(variables.mu), variables.alpha * variables.gamma) * variables.holderb(variables.C * variables.Rhob(variables.mu), variables.delta * variables.Beta))/(2 * variables.zb(13) * variables.zb(34) * variables.zb(32) * variables.zb(42)) + (variables.holderb(variables.C * variables.Rhoa(variables.mu), variables.alpha * variables.delta) * variables.holderb(variables.C * variables.Rhob(variables.mu), variables.Beta * variables.gamma))/(2 * variables.zb(14) * variables.zb(42) * variables.zb(43) * variables.zb(23))
variables.Rhoab(variables.mu, variables.alpha * variables.Beta) * variables.Rhob(variables.mu * variables.gamma * variables.delta) + variables.Rhoab(variables.mu, variables.alpha * variables.gamma) * variables.Rhob(variables.mu * variables.delta * variables.Beta) + variables.Rhoab(variables.mu, variables.alpha * variables.delta) * variables.Rhob(variables.mu * variables.Beta * variables.gamma) == 0
np.cross(variables.i/2 * variables.gab(2, variables.o) * (2 * math.pi)**(10) * variables.deltaaf(10, summation(variables.kb(variables.i), variables.i)) * variables.Trbf(variables.v, (variables.ta(variables.ab(1)) * variables.ta(variables.ab(2)) * variables.ta(variables.ab(3)) * variables.ta(variables.ab(4)))) * quad(diff(variables.x) * variables.xas(-variables.SlopeRegge * variables.s - 1) * (1 - variables.x)**(-variables.SlopeRegge * variables.u - 1), (0, 1)), (variables.ulb(1) * variables.Rhoa(variables.mu) * variables.ub(2) * variables.ulb(3) * variables.Rhoa(variables.mu) * variables.ub(4) + variables.x * variables.ulb(1) * variables.Rhoa(variables.mu) * variables.ub(3) * variables.ulb(2) * variables.Rhoa(variables.mu) * variables.ub(4))) 
# check permutations 2.115.22, 25, 26
variables.Kf(variables.ub(1), variables.ub(2), variables.ub(3), variables.ub(4)) == 1/8 * (variables.u * variables.ulb(1) * variables.Rhoa(variables.mu) * variables.ub(2) * variables.ulb(3) * variables.Rhob(variables.mu) * variables.ub(4) - variables.s * variables.ulb(1) * variables.Rhoa(variables.mu) * variables.ub(4) * variables.ulb(3) * variables.Rhob(variables.mu) * variables.ub(2))
variables.s == - (variables.kb(1) + variables.kb(2))**(2) 
variables.t == - (variables.kb(1) + variables.kb(3))**2 
variables.u == - (variables.kb(1) + variables.kb(4))**2
1/(variables.SlopeRegge**2 * variables.s * variables.u) - (math.pi**2)/6  + variables.Of(variables.SlopeRegge) 
(math.pi**2 * variables.SlopeRegge**2)/(np.cross(2, math.factorial(4) * variables.Gab(2, variables.YM))) * variables.ta(variables.mu * variables.v * variables.sigma * variables.rho * variables.alpha * variables.Beta * variables.gamma * variables.delta) * variables.Trbf(variables.v, (variables.Fb(variables.mu * variables.v) * variables.Fb(variables.sigma * variables.rho) * variables.Fb(variables.alpha * variables.Beta) * variables.Fb(variables.gamma * variables.delta)))
variables.Abf(variables.c, (variables.s, variables.t, variables.u, variables.SlopeRegge, variables.gb(variables.c))) == - (math.pi * variables.i * variables.gab(2, variables.c) * variables.SlopeRegge)/(variables.gab(4, variables.o)) * variables.Abf(variables.o, (variables.s, variables.t, 1/4 * variables.SlopeRegge, variables.gb(variables.o))) * variables.star(variables.Abf(variables.o, variables.t, variables.u, 1/4 * variables.SlopeRegge, variables.gb(variables.o))) * math.sin((math.pi * variables.SlopeRegge * variables.t)/4)
-(variables.i * variables.kappaa(2) * variables.SlopeRegge)/4 * (variables.Rhof(-1/4 * variables.SlopeRegge * variables.s) * variables.Rhof(-1/4 * variables.SlopeRegge * variables.t) * variables.Rhof(-1/4 * variables.SlopeRegge * variables.u))/(variables.Rhof(1 + 1/4 * variables.SlopeRegge * variables.s) * variables.Rhof(1 + 1/4 * variables.SlopeRegge * variables.t) * (variables.Rhof(1 + 1/4 * variables.SlopeRegge * variables.u))) * variables.Kbf(variables.c, (variables.eb(1), variables.eb(2), variables.eb(3), variables.eb(4)))
- 64/(variables.SlopeRegge**3 * variables.s * variables.t * variables.u) - 2 * variables.zetaf(3) + variables.Of(variables.SlopeRegge)
variables.zetaf(variables.k) == summation(1/(variables.ma(variables.k)))
variables.hat(variables.ka(-2)) * variables.bracket(variables.jaf(variables.ab(1), variables.zb(1)) * variables.jaf(variables.ab(2), variables.zb(2)) * variables.jaf(variables.ab(2), variables.zb(2)) * variables.jaf(variables.ab(3), variables.zb(3)) * variables.jaf(variables.ab(4), variables.zb(4))) == (variables.deltaa(variables.ab(1) * variables.ab(2)) * variables.deltaa(variables.ab(3) * variables.ab(4)))/(variables.zab(2, 12) * variables.zab(2, 34)) - (variables.fa(variables.ab(1) * variables.ab(2) * variables.b) * variables.fa(variables.b * variables.ab(3) * variables.ab(4)))/(variables.hat(variables.k) * variables.zb(12) * variables.zb(23) * variables.zb(24) * variables.zb(34)) + (2) + (2) # check symmetric states 2.117.35
-variables.hat(variables.ka(-1)) * variables.fa(variables.ab(1) * variables.ab(2) * variables.b) * variables.fa(variables.b * variables.ab(3) * variables.ab(4)) == 2 * variables.Trbf(variables.v, (variables.brackets(variables.ta(variables.ab(1)), variables.ta(variables.ab(2))) * variables.ta(variables.b))) * variables.Trbf(variables.v, (variables.ta(variables.b)) * variables.brackets(variables.ta(variables.ab(3)), variables.ta(variables.ab(4)))) == 2 * variables.Trbf(variables.v, (variables.brackets(variables.ta(variables.ab(1)), variables.ta(variables.ab(2))) * variables.brackets(variables.ta(variables.ab(3)), variables.ta(variables.ab(4)))))
#2.118.2
variables.dirac(variables.VOab(-1, 2)) == 2* variables.Lab(variables.m, 0) * variables.dirac(variables.VOab(-1, 2)) == variables.bracketc(variables.Gab(variables.m, 1/2), variables.Gab(variables.m, -1/2)) * variables.dirac(variables.VOab(-1, 2)) == variables.Gab(variables.m, 1/2) * variables.Gab(variables.m, -1/2) * variables.dirac(-1, 2)
variables.Xf(variables.z) == np.dot(variables.Qb(variables.B), variables.zetaf(variables.z)) == variables.Tbf(variables.F, variables.z) * variables.deltaf(variables.Betaf(variables.z)) - diff(variables.bf(variables.z), variables.z) * variables.deltapf(variables.Betaf(variables.z))
variables.deltaf(variables.Beta) == variables.ea(variables.phi)
variables.thetaf(variables.Beta) == variables.zeta
variables.bracket(variables.zetaf(variables.z)) == 1
variables.Xf(variables.zb(1)) * variables.zetaf(variables.zb(2)) == np.dot(variables.Qb(variables.B), (variables.zetaf(variables.zb(1)) * variables.zetaf(variables.zb(2)))) == np.dot((variables.zetaf(variables.zb(1)) * variables.Qb(variables.B)), variables.zetaf(variables.zb(2))) == variables.zetaf(variables.zb(1)) * variables.Xf(variables.zb(2))
sp.limit(variables.Xf(variables.z) * variables.VOaf(-1, 0), variables.z, 0)
variables.ea(variables.phi) * variables.Tabf(variables.m, variables.F, variables.z) * variables.ea(-variables.phi) * variables.OOf(0) == variables.z * variables.Tabf(variables.m, variables.F, variables.z) * variables.OOf(0) + variables.Of(variables.za(2))
sp.limit(variables.Xf(variables.z) * variables.VOaf(-1, 0), variables.z, 0) == variables.VOaf(0, 0)
variables.nb(variables.X) == 2 * variables.g - 2 + variables.nb(variables.B) + (variables.nb(variables.F))/2
variables.zb(variables.m) == variables.fbf(variables.m * variables.n, variables.zb(variables.n)) + variables.thetab(variables.n) * variables.gbf(variables.m * variables.n, variables.zb(variables.n)) * variables.hbf(variables.m * variables.n, variables.zb(variables.n))
variables.thetab(variables.m) == variables.gbf(variables.m * variables.n, variables.zb(variables.n)) + variables.thetab(variables.n) * variables.hbf(variables.m * variables.n, variables.zb(variables.n))
variables.habf(2, variables.m * variables.n, variables.zb(variables.n)) == diff(variables.fbf(variables.m * variables.n, variables.zb(variables.n)), variables.z) + variables.gbf(variables.m * variables.n, variables.zb(variables.n)) * diff(variables.gbf(variables.m * variables.n, variables.zb(variables.n)))
variables.zb(variables.m) == variables.fbf(variables.m * variables.n, variables.zb(variables.n))
variables.thetab(variables.m) == variables.thetab(variables.n) * variables.hbf(variables.m * variables.n, variables.zb(variables.n))
variables.habf(2, variables.m * variables.n, variables.zb(variables.n)) == diff(variables.fbf(variables.m * variables.n, variables.zb(variables.n)), variables.z)
variables.hb(variables.m * variables.n) * variables.hb(variables.n * variables.p) * variables.hb(variables.p * variables.m) == 1
variables.u == 1/variables.z 
variables.phi == variables.i * variables.theta/variables.z 
variables.ff(variables.z) == (variables.alpha * variables.z + variables.Beta)/(variables.gamma * variables.z + variables.delta) 
variables.gf(variables.z) == variables.epsilonb(1) + variables.epsilonb(2) * variables.z 
(variables.z, variables.theta) == (variables.z + 2* math.pi, variables.etab(1) * variables.theta) == (variables.z + 2 * math.pi * variables.tau, variables.etab(2) * variables.theta)
(variables.z, variables.theta) == (variables.z + 2 * math.pi, variables.theta) == (variables.z + 2 * math.pi * variables.tau + variables.theta * variables.v, variables.theta + variables.v)
(variables.z, variables.theta) == (variables.z + variables.theta * variables.epsilon, variables.theta + variables.epsilon)
variables.nb(variables.v) == 2 * variables.g - 2 + variables.nb(variables.B) + (variables.nb(variables.F))/2
#2.124.24 ommitted 
variables.Bb(variables.j) == summation(integrate((diff(variables.zb(variables.m)) * diff(variables.thetab(variables.m)))/(2 * math.pi * variables.i) * variables.Bf(variables.zb(variables.m), variables.thetab(variables.m)) * variables.bracketsb((diff(variables.zb(variables.m), variables.z))/(diff(variables.tb(variables.j), variables.z)) - (diff(variables.thetab(variables.m), variables.z))/(diff(variables.tb(variables.j), variables.z)) * variables.thetab(variables.m), (variables.zb(variables.n), variables.thetab(variables.n))), variables.Cb(variables.m * variables.n)), (variables.m * variables.n))
np.dot(variables.Qb(variables.B), variables.Bb(variables.zB)) == variables.Tf(variables.zB) == variables.Tbf(variables.F, variables.z) + variables.theta * variables.Tbf(variables.B, variables.z)
variables.fbf(12, variables.zb(2)) == variables.zb(2)
variables.gbf(12, variables.zb(2)) == variables.v * variables.alphaf(variables.zb(2))
variables.Bf(variables.brackets(variables.alpha)) == integrate((diff(variables.zb(1)))/(2 * math.pi * variables.i) * variables.alphaf(variables.zb(1)) * variables.Betaf(variables.zb(1), variables.theta), 2* math.pi) # contour integral
variables.v * variables.Tf(variables.brackets(variables.alpha))
variables.Tf(variables.brackets(variables.alpha)) * variables.deltaf(variables.Bf(variables.brackets(variables.alpha))) == np.dot(variables.Qb(variables.B), variables.thetaf(variables.Bf(variables.brackets(variables.alpha))))
variables.alphaf(variables.zb(1)) == 1/(variables.zb(1) - variables.zb(0))
integrate(variables.Bb(2) * variables.Trbf(variables.v, variables.Fab(4, 2)))
(2/variables.SlopeRegge)**(5/2) * variables.gab(5, variables.c) * integrate((diff(variables.tau) * diff(variables.taul))/(8 * variables.taub(2)) * variables.brackets(np.prod(variables.d2(variables.wb(variables.i)), (variables.i, 1, 5))) * variables.bracketb(np.cross(variables.bf(0) * variables.bftilde(0) * variables.cftilde(0) * variables.cf(0) * variables.Xf(0), variables.brackets(np.prod(variables.hat(variables.ka(-1/2)) * variables.jaf(variables.ab(variables.i)), np.dot(variables.i * variables.eb(variables.i), diff(variables.X, variables.zl)) + np.dot(1/2 * variables.SlopeRegge * variables.kb(variables.i), variables.psitilde * variables.eb(variables.i), variables.psitilde)) * variables.eaf(np.dot(variables.i * variables.kb(variables.i), variables.X), (variables.wb(variables.i), variables.wlb(variables.i))))), variables.i * variables.eb(5, variables.mu * variables.v) * diff(variables.xa(variables.mu), variables.z) * variables.deltaf(variables.gammatilde) * variables.psiatilde(variables.v) * variables.eaf(np.dot(variables.i * variables.kb(5), variables.X), (variables.wb(5), variables.wlb(5))), (variables.P, variables.P)), variables.F)
variables.deltaf(variables.Betatilde) * variables.i * (2/variables.SlopeRegge)**(1/2) * variables.psiatilde(variables.rho) * diff(variables.xb(variables.rho), variables.zl)
# check trace 2.126.4
variables.bracketb(diff(variables.xa(variables.mu, variables.wb(5)), variables.z) * diff(variables.xa(variables.rho, 0), variables.zl) * np.prod(variables.ea(np.dot(variables.i * variables.kb(variables.i), variables.Xf(variables.wb(variables.i), variables.wlb(variables.i)))), (variables.i, 1, 5)), variables.X) 
- variables.i * (2 * math.pi)**(10) * variables.deltaaf(10, summation(variables.kb(variables.i), variables.i)) * (variables.etaa(variables.mu * variables.rho) * variables.SlopeRegge)/(8 * math.pi * variables.taub(2) * (4 * math.pi**2 * variables.SlopeRegge * variables.taub(2))**5 * Abs(variables.etaf(variables.tau))**20)
variables.bracketb(variables.bf(0) * variables.bftilde(0) * variables.cftilde(0) * variables.cf(0), variables.b * variables.c) == Abs(variables.etaf(variables.tau))**4
variables.bracketb(variables.deltaf(variables.Betaftilde(0)) * variables.deltaf(variables.gammaftilde(variables.wlb(5))), variables.Beta * variables.gamma) == variables.star(variables.brackets(variables.etaf(variables.tau)**(-2)))
variables.hat(variables.ka(-2)) * variables.bracketb(variables.jaf(variables.ab(1), variables.wb(1)) * variables.jaf(variables.ab(2), variables.wb(2)) * variables.jaf(variables.ab(3), variables.wb(3)) * variables.jaf(variables.ab(4), variables.wb(4)), variables.g)
variables.jaf(variables.a, variables.w) * variables.jaf(variables.b, 0) == variables.Tf(variables.brackets(variables.hat(variables.Qaf(variables.a, variables.w)) * variables.hat(variables.Qaf(variables.b, 0))))  - math.pi * variables.deltaaf(2, (variables.w, variables.wl)) * variables.deltaa(variables.a * variables.b)
(variables.deltaa(variables.a * variables.b))/2 * integrate(variables.d2(variables.w) * 1/(variables.wa(2)) * (variables.w * variables.wl)**(np.dot(variables.k, variables.kp)))
(-1 + np.dot(variables.k, variables.kp))**(-1) * diff(variables.wa(-1 + np.dot(variables.k, variables.kp)) * variables.wla(np.dot(variables.k, variables.kp)), variables.w)
variables.bracket(variables.jaf(variables.ab(1), variables.wb(1)) * variables.jaf(variables.ab(2), variables.wb(2))) == variables.Trf(variables.bracketc(math.exp(2 * math.pi * variables.i * variables.H) * variables.Tf(variables.brackets(variables.hat(variables.Qaf(variables.ab(1), variables.wb(1))) * variables.hat(variables.Qaf(variables.ab(2), variables.wb(2))))))) - variables.deltaa(variables.a * variables.b) * math.pi * variables.deltaaf(2, (variables.wb(12), variables.wlb(12))) == variables.Trf(variables.bracketc(math.exp(2 * math.pi * variables.i * variables.tau * variables.H) * variables.hat(variables.Qa(variables.ab(1, 2))))) - (variables.deltaa(variables.a * variables.b))/(8 * math.pi * variables.taub(2)) # check parentheses hqtqa terms 2.129.13
variables.ff(variables.q, variables.z) == variables.bracket(math.exp(np.dot(variables.z, variables.jl))) == math.exp(-(np.dot(variables.z, variables.z))/(16 * math.pi * variables.taub(2))) * variables.Trf(math.exp(2 * math.pi * variables.i * variables.tau * variables.H) * math.exp(np.dot(variables.z, variables.hat(variables.Q))))
variables.ff(variables.q, variables.z) == variables.etaf(variables.tau)**(-16) * math.exp(-(np.dot(variables.z, variables.z))/(16 * math.pi * variables.taub(2))) * summation(variables.qa((variables.la(2))/2) * math.exp(np.dot(2**(-1/2) * variables.z, variables.l)), (variables.l, variables.Rho))
# check amplitude gathering 2.129.16
variables.hat(variables.ff(variables.q, variables.z)) == variables.etaf(variables.tau)**(-8) * variables.ff(variables.q, variables.z)
-1/(2**9 * math.pi**6 * variables.SlopeRegge) * integrate(variables.Bb(2) * integrate((variables.d2(variables.tau))/(variables.tauab(2, 2)) * variables.hat(variables.ff(variables.q, variables.Fb(2))), variables.F))
(variables.hat(variables.ff(variables.q, variables.Fb(2))))/(variables.tauab(2, 2)) == -(32 * math.pi * variables.i)/(np.dot(variables.Fb(2), variables.Fb(2))) * (diff(variables.hat(variables.ff(variables.q, variables.Fb(2))), variables.z))/(diff(variables.taul, variables.z))
# check evaluation method 2.130.20
-(1)/(2**4 * math.pi**5 * math.factorial(6) * variables.SlopeRegge) * integrate((variables.Bb(2) * variables.Trbf(variables.a, variables.Fab(6, 2)))/(np.dot(variables.Fb(2), variables.Fb(2)))) == -(1)/(2**4 * math.pi**5 * math.factorial(4) * variables.SlopeRegge) * integrate(variables.Bb(2) * (variables.Trbf(variables.a, variables.Fab(6, 2)))/(variables.Trbf(variables.a, variables.Fab(2, 2))))
1/7200 * variables.bracketc(variables.brackets(variables.Trbf((variables.a, 1), variables.Fab(2, 2)))**2 + variables.brackets(variables.Trbf((variables.a, 2), variables.Fab(2, 2)))**2 - variables.Trbf((variables.a, 1), variables.Fab(2, 2)) * variables.Trbf((variables.a, 2), variables.Fab(2, 2)))
(4 * variables.gab(4, variables.c))/(variables.SlopeRegge**2) * integrate((diff(variables.tau) * diff(variables.taul))/(8 * variables.taub(2)) * variables.brackets(np.prod(integrate(variables.d2(variables.wb(variables.i))), (variables.i, 1, 4))) * summation()) # incomplete, finish summation values, 2.131.23
# simplified 2.131.24
variables.Thetabtilde(variables.alpha) == variables.thetabtilde(variables.alpha)
variables.kb(variables.i) * variables.eb(variables.j) * variables.psiatilde(variables.brackets(variables.i, variables.j))
variables.psiatilde(variables.brackets(variables.i, variables.j)) == 1/4 * variables.thetaatilde(variables.T) * variables.Rhoa(variables.i * variables.j) * variables.thetatilde 
1/(2**8 * math.pi **5 * math.factorial(4) * variables.SlopeRegge) * variables.ta(variables.mu * variables.v * variables.sigma * variables.rho * variables.alpha * variables.Beta * variables.gamma * variables.delta) * variables.Trbf(variables.v, (variables.Fb(variables.mu * variables.v) * variables.Fb(variables.sigma * variables.rho) * variables.Fb(variables.alpha * variables.Beta) * variables.Fb(variables.gamma * variables.delta)))
variables.Gbf(variables.mu * variables.v, variables.x) == variables.etab(variables.mu * variables.v) 
variables.Phif(variables.x) == variables.Phib(0) 
integrate(variables.daf(10, variables.x) * (-variables.G)**(1/2) * variables.Vf(variables.Phi))
